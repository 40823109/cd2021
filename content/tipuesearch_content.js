var tipuesearch = {"pages": [{'title': 'About', 'text': '40823109 \n 倉儲 :\xa0 cd2021倉儲 \n 網站 :\xa0 cd2021網站 \n YT\xa0 \xa0:\xa0 YT網站 \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'Stage1', 'text': '', 'tags': '', 'url': 'Stage1.html'}, {'title': 'W1', 'text': '', 'tags': '', 'url': 'W1.html'}, {'title': 'SSH setup', 'text': '(1) 在 home 將之前建立的key ， .ssh資料夾複製過來。 \n \n (2) 開啟 putty，將 github.com load下來。 \n \n (3) 找到 SSH 下的 Auth 將key路徑改成剛剛複製過來的key，然後回到剛剛的介面按下save。 \n \n (4) \n 修改 start 增加框框中的兩行指令。 \n \n (4) 確認 tmp/cd2021/.git 中 ， config修改如下。 \n \n (5) 重新啟動後即可完成SSH設定。 \n', 'tags': '', 'url': 'SSH setup.html'}, {'title': 'set website', 'text': '(1) 進入到\xa0 https://github.com/mdecourse/cmstemplate \xa0按下 Use this template 。 \n \n (2) 輸入倉儲名稱 cd2021 ，建立倉儲。 \n \n (3) 進入到 tmp 下 ， 輸入 git clone --recurse-submodules 倉儲連結 .git\xa0 \n \n (4) 進到 tmp/cd2021/cmsimde/ 輸入，python wsgi.py ，可執行網站。 \n \n (5) 開起瀏覽器，輸入\xa0 https://localhost:9443 \xa0，即可編輯網站。 \n \n \n', 'tags': '', 'url': 'set website.html'}, {'title': "leo can't use", 'text': '(1) 輸入 leo 指令跳出無限迴圈 \n \n (2) 解決方法 : \n 在 home 目錄下建立一個 .leo 資料夾 ，並建立一個 .leoID 文件檔後， 重新啟動即可成功。 \n \n \n \n', 'tags': '', 'url': "leo can't use.html"}, {'title': 'W2', 'text': '討論分工部分 : 40823109繪製草圖與3D圖 \n 40823112製作程式模擬 \n YT影片 : \n \n', 'tags': '', 'url': 'W2.html'}, {'title': '草圖繪製', 'text': '1. 手繪手稿 \n \xa0 \n 2. 發現齒輪無法傳動後，更正的手稿。 \n \n 3.最終確定的手稿。 \n \n', 'tags': '', 'url': '草圖繪製.html'}, {'title': '3D圖繪製', 'text': '3D圖檔 :\xa0 \n 達爾文船零件圖檔 \n 組合圖 : \n \n 零件圖 : \n 1. 船身 \n \n 2. 輪 \n \n 3. 輸入軸支撐 \n \n 4. 輸入軸 \n \n 5. 傳動齒輪1支撐 \n \n 6. 傳動齒輪1 \n \n 7. 傳動齒輪軸2支撐 \n \n 8. 傳動齒輪軸2 \n \n 9. 惰輪支撐 \n \n 10. 惰輪 \n \n 11. 輪軸芯 \n \n', 'tags': '', 'url': '3D圖繪製.html'}, {'title': 'W3', 'text': '完成品 \n \n', 'tags': '', 'url': 'W3.html'}, {'title': '3D爆炸圖與工作圖', 'text': '圖檔 :\xa0 工作圖檔 \n 3D爆炸圖 : \n \n 2D工作圖 : \n 船體 \n \n 齒輪及傳動件 : \n \n 輪 : \n \n', 'tags': '', 'url': '3D爆炸圖與工作圖.html'}, {'title': '傳動設計修改', 'text': '修改齒輪尺數與樣式變更 \n Q :\xa0 模擬後發現輸出輪與左右齒輪傳動不穩，速度會產生簡諧運動， \n A : 增加齒數與更改齒型從而能更加的穩定運轉。 \n (修改前) \n \n (修改後成品) \n \n \n', 'tags': '', 'url': '傳動設計修改.html'}, {'title': 'W4', 'text': '第一階段報告 \n \n 影片 :\xa0 \n \n \n', 'tags': '', 'url': 'W4.html'}, {'title': 'stage2', 'text': '', 'tags': '', 'url': 'stage2.html'}, {'title': 'W5', 'text': "Stage2 開始執行，討論後決定以第一組的專題主題繼續進行下去。 \n 組別 : stage2-ag1 \n 組員 : 40823145、40823108、40823112、40823109 \n 為了讓模型能夠按照我們的意思做動，嘗試著編寫Lua程式並以方向鍵進行控制。 \n 下方為第一次測試的程式 \n Lua程式: \n threadFunction=function()\n    -- put your actuation code here\n while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n    -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\nif (auxiliaryData[1]==2007) then\n                -- up key\n                velocity=1000\n                torque=10000\n                Shape4 = 1000\n                Shape7 = 1000\n            end\n            if (auxiliaryData[1]==2008) then\n                -- down key\n                velocity=1000\n                torque=10000\n                Shape4 = 1000\n                Shape7 = 1000\n            end\n            if (auxiliaryData[1]==2009) then\n                -- left key\n                velocity=1000\n                torque=10000\n                Shape4 = 1000\n                Shape7 = 1000\n            end\n            if (auxiliaryData[1]==2010) then\n                -- right key\n                velocity=1000\n                torque=10000\n                Shape4 = 1000\n                Shape7 = 1000\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    if Shape4 == 1\n        then sim.setJointPosition(joint_1, 1000, orientation)\n    if Shape7 == 1\n        then sim.setJointPosition(joint_2, 1000, orientation)\n    end\n        sim.setJointTargetVelocity(joint,velocity)\n    end\n        joint_1=sim.getObjectHandle('joint_1')\n        joint_2=sim.getObjectHandle('joint_2')\n        Shape4=sim.getObjectHandle('Shape4')\n        Shape7=sim.getObjectHandle('Shape7')\n        velocity=0\n        torque=0\n        Shape4 = 0\n        Shape7 = 0\nend \n 因部分語法有誤，日後待除錯。 \n", 'tags': '', 'url': 'W5.html'}, {'title': 'W6', 'text': "這週我們試著使機器人可以用方向鍵來控制，但程式修改後還是有錯誤。 \n 第二次Lua程式測試: \n function sysCall_init()\n    -- do some initialization here\n    left_front_handle= sim.getObjectHandle('left_front')\n    left_back_handle= sim.getObjectHandle('left_back')\n    right_back_handle= sim.getObjectHandle('right_back')\n    right_front_handle= sim.getObjectHandle('right_front')\n    \n    joint_1_handle= sim.getObjectHandle('joint_1')\n    \n    joint_2_handle= sim.getObjectHandle('joint_2')\n    MaxVel=10\n    leftvelocity=0\n    rightvelocity=0\n    dVel=0.5;\n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==32) then\n                -- right key\n                leftvelocity=0\n                rightvelocity=0\n                sim.setJointForce(left_front_handle, 0)\n                sim.setJointForce(left_back_handle, 0)\n                sim.setJointForce(right_back_handle, 0)\n                sim.setJointForce(right_front_handle, 0)\n                \n                \n                sim.setJointForce(joint_1_handle, 1000)\n                \n                sim.setJointForce(joint_2_handle, 1000)\n                break\n            else\n            --sim.setJointForce(left_front_handle, 10000)\n            sim.setJointForce(left_back_handle, 10000)\n            sim.setJointForce(right_back_handle, 10000)\n            --sim.setJointForce(right_front_handle, 10000)\n            \n            sim.setJointForce(joint_1_handle, 0)\n            \n            sim.setJointForce(joint_2_handle, 0)\n            end\n            if (auxiliaryData[1]==2007) then\n                -- up key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==2008) then\n                -- down key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==2009) then\n                -- left key\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==2010) then\n                -- right key\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity-dVel\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    \n    if leftvelocity>MaxVel then\n        leftvelocity=MaxVel\n    end\n    if leftvelocity<-MaxVel then\n        leftvelocity=-MaxVel\n    end\n    \n    if rightvelocity>MaxVel then\n                rightvelocity=MaxVel\n    end\n    if rightvelocity<-MaxVel then\n                rightvelocity=-MaxVel\n    end\n    \n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\n    \nend\n\nfunction sysCall_sensing()\n    -- put your sensing code here\nend\n\nfunction sysCall_cleanup()\n    -- do some clean-up here\nend\n\n-- See the user manual or the available code snippets for additional callback functions and details \n 第二次更新後，還是無法順利控制，將於下週改進。 \n", 'tags': '', 'url': 'W6.html'}, {'title': 'W7', 'text': "經過前兩週的測試，這週我們成功使機器人可以用方向鍵進行操控。 \n 模擬圖 : \n \n 第三次Lua程式 (成功) \n function sysCall_init() \n    left_front_handle= sim.getObjectHandle('left_m')\n    left_back_handle= sim.getObjectHandle('left_m')\n    right_back_handle= sim.getObjectHandle('right_m')\n    right_front_handle= sim.getObjectHandle('right_m')\n    MaxVel=2\n    leftvelocity=0\n    rightvelocity=0\n    dVel=0.5;\n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\nend\n\nfunction sysCall_actuation() \n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==32) then\n                -- right key\n                leftvelocity=0\n                rightvelocity=0\n                sim.setJointForce(left_front_handle, 0)\n                sim.setJointForce(left_back_handle, 0)\n                sim.setJointForce(right_back_handle, 0)\n                sim.setJointForce(right_front_handle, 0)\n                break\n            else\n                --sim.setJointForce(left_front_handle, 10000)\n                sim.setJointForce(left_back_handle, 10000)\n                sim.setJointForce(right_back_handle, 10000)\n                --sim.setJointForce(right_front_handle, 10000)\n            end\n            if (auxiliaryData[1]==2007) then\n                -- up key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==2008) then\n                -- down key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==2009) then\n                -- left key\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==2010) then\n                -- right key\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity-dVel\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    \n    if leftvelocity>MaxVel then\n        leftvelocity=MaxVel\n    end\n    if leftvelocity<-MaxVel then\n        leftvelocity=-MaxVel\n    end\n    \n    if rightvelocity>MaxVel then\n                rightvelocity=MaxVel\n    end\n    if rightvelocity<-MaxVel then\n                rightvelocity=-MaxVel\n    end\n    \n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\n    \nend  \n 已成功使用方向鍵控制模型，下週將會加入視覺傳感器與力傳感器，讓模型在遇到物體時可以自動避開。 \n", 'tags': '', 'url': 'W7.html'}, {'title': 'W8', 'text': '我們加入了力傳感器、視覺傳感器，讓模型在碰觸障礙物時，可以自行避開並選擇路徑上無障礙物之路線進行移動。 \n 模擬圖 :\xa0 \n \n 模型Lua: \n function sysCall_init()\n    \n    \nend\n\nfunction sysCall_actuation()\n    \nend\n\nfunction sysCall_sensing()\n    \nend\n\nfunction sysCall_cleanup()\n    \nend\n\n\n\nfunction sysCall_afterDelete(inData)\n    for key,value in pairs(inData.objectHandles) do\n        print("Object with handle "..key.." was deleted")\n    end\n    \nend\n\nfunction sysCall_afterCreate(inData)\n    for key,value in pairs(inData.objectHandles) do\n        print("Object with handle "..value.." was created")\n    end\nend\n--]]\nfunction speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    \n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) \n    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") \n    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") \n    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") \n    minMaxSpeed={120*math.pi/180,300*math.pi/180} \n    backUntilTime=-1 \n   \n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.create(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*1\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor) \n    \n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end \n\n    if (backUntilTime<sim.getSimulationTime()) then\n        \n        sim.setJointTargetVelocity(leftMotor,speed)\n        sim.setJointTargetVelocity(rightMotor,speed)\n    else\n        \n        sim.setJointTargetVelocity(leftMotor,-speed/5)\n        sim.setJointTargetVelocity(rightMotor,-speed/200)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui)\nend \n 路徑Lua: \n require(\'graph_customization\') \n 力傳感器Lua: \n function sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend\n\nfunction sysCall_init()\nend\n\nfunction sysCall_trigger(inData)\n    -- callback function automatically added for backward compatibility\n    sim.breakForceSensor(inData.handle)\nend \n 視覺傳感器Lua: \n function sysCall_init()\nend\n\nfunction sysCall_vision(inData)\n    -- callback function automatically added for backward compatibility\n    -- (vision sensor have no filters anymore, but rather a callback function where image processing can be performed)\n    local retVal={}\n    retVal.trigger=false\n    retVal.packedPackets={}\n    simVision.sensorImgToWorkImg(inData.handle)\n    simVision.edgeDetectionOnWorkImg(inData.handle,0.200000)\n    simVision.workImgToSensorImg(inData.handle,false)\n    return retVal\nend\n \n', 'tags': '', 'url': 'W8.html'}, {'title': 'W9', 'text': '第二次報告 \n 影片 :\xa0 \n \n', 'tags': '', 'url': 'W9.html'}, {'title': 'stage3', 'text': '', 'tags': '', 'url': 'stage3.html'}, {'title': 'W10', 'text': '', 'tags': '', 'url': 'W10.html'}, {'title': 'task1', 'text': '利用python程式讀取  stage3_2a.txt ，建立 Stage3 的分組倉儲，分組網頁，以及各組員倉儲及網頁連結。 \n 程式與註解如下 : \n # open file, default is read mode, since txt content no chinese char4\n# no encoding = "UTF-08" is needed\nwith open("123.txt") as fh:\n    #匯入txt檔內容.將它命名為fh\n    data = fh.readlines()\n     #readlines()方法讀取整個檔案所有行，儲存在一個列表(list)變數中，每行作為一個元素。\n    data = [a.replace(\'4823122\',\'40823122\') for a in data]\n     #因為有一個學號少打了一個0，所以使用replace() ，將正確學號取代錯誤學號，並傳回data。\n    data = [c.replace(\'\\t\\t\\t\\t\',\'\') for c in data]\n     #有一組只有6人，因此需消除後面多的2格空格。\n    data = [b.replace(\'_\',\'-\') for b in data]\n     #將_更改成-以方便之後的讀取。\n     #print(data)\n     #印出data。\n#print(len(data))\nfor i in range(len(data)):\n    # 使用range設定範圍，len(data)=6進行for迴圈，變數為i。\n    group = data[i].rstrip("\\n").split("\\t")\n    #將data列表中第i項,去除元素\\n(換行)利用\\t(空格)分割變成元素(逗號自動補上)\n    \n    #group（）用來提出分組截獲的字符串，()用來分組。\n    #rstrip() 删除 string 字符串末尾的指定字符。\n    #split() 通過指定分隔符對字符串進行切片，如果参数 num 有指定值，則分隔 num+1 個子字符串。\n    \n    #print(group)\n    print(\'<p>\'+group[0]+\' | <a href="https://\'+group[1]+\'.github.io/stage3-ag\'+group[0]+\'">網站</a> | <a href="https://github.com/\'+group[2]+\'/\'+group[0]+\'">倉儲</a></p>\')\n    #group[0][9]=第0個第9位\n    #用print依序索引group list中的元素,放入html格式,依序print出來\n \n    for j in range(2,18,2):\n        #range(2,18,2):選取文字檔中的第2格到第18格，每跳兩格選一次\n        try:\n            print(\'<p>\'+group[j]+\' | Website:\'+\'<a href="https://\'+group[j]+\'.github.io/cd2021\'+\'">\'+group[j]+\'</a>\'+\' | Repository:\'+\'<a href="https://github.com/\'+group[j]+\'/cd2021\'+\'">\'+group[j]+\'</a>\'+\' | Group Website:\'+\'<a href="https://\'+group[j]+\'.github.io/\'+group[0]+\'">\'+group[j]+\'</a></p>\')\n            #用print依序索引group list中的元素,放入html格式,依序print出來\n                   #差別在於這行是取組員的但因為有一組只有6人超出範圍所以一定會error\n        except:\n            continue \n \n', 'tags': '', 'url': 'task1.html'}, {'title': 'task2', 'text': '使用 Python remote API 進行操控 stage1 與 stage2 所完成的 coppeliasim 場景 \n YT : \n \n \n Python remote API 程式 stage 1 \n import sim as vrep\nimport sys\n# child threaded script: \n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19999, True, True, 5000, 5)\n \nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,boat_motor_handle=vrep.simxGetObjectHandle(clientID,\'boat_motor\',vrep.simx_opmode_oneshot_wait)\n \nif errorCode == -1:\n    print(\'Can not find motor\')\n    sys.exit()\n \nerrorCode=vrep.simxSetJointTargetVelocity(clientID,boat_motor_handle,0, vrep.simx_opmode_oneshot_wait) \n Python remote API 程式 stage 2 \n import sim as vrep\nimport sys\n# child threaded script: \n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19999, True, True, 5000, 5)\n \nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,left_m_handle=vrep.simxGetObjectHandle(clientID,\'left_m\',vrep.simx_opmode_oneshot_wait)\n \nerrorCode,right_m_handle=vrep.simxGetObjectHandle(clientID,\'right_m\',vrep.simx_opmode_oneshot_wait)\n \nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n \nerrorCode=vrep.simxSetJointTargetVelocity(clientID,left_m_handle,0, vrep.simx_opmode_oneshot_wait)\nerrorCode=vrep.simxSetJointTargetVelocity(clientID,right_m_handle,0, vrep.simx_opmode_oneshot_wait)\n \n', 'tags': '', 'url': 'task2.html'}, {'title': 'W11', 'text': '', 'tags': '', 'url': 'W11.html'}, {'title': 'task 3', 'text': '介紹使用\xa0 Python remote API 控制 coppeliasim 場景，與SSH 設定。 \n \n', 'tags': '', 'url': 'task 3.html'}, {'title': 'W13', 'text': '使用 python API 控制 RoboDK \n \n 下載  RoboDK  檔案與  Pick_and_place \n 完成後打開 RoboDK 中的\xa0a_start_robodk.bat \n 載入\xa0pick_and_place 中的\xa0Example 02-1 - Pick and place with Python.rdk \n 將\xa0pick_and_place.py 拉進 SciTE 編譯器裡面 \n 更改程式中的 IP位置為自己電腦的IP "127.0.0.1" \n 按下 Tools中的 GO 即可執行。 \n \n 操作影片 : \n \n \n', 'tags': '', 'url': 'W13.html'}, {'title': 'W15', 'text': '使用 gogs 將github帳號被封的倉儲丟過去 。 \n \n \n 在 https://fossil.kmol.info:3443 中申請帳號 \n 建立一個空的倉儲 cd2021 \n 進入可攜系統中cd2021 輸入 git remote add fossil  http://fossil.kmol.inof:3000/帳號/cd2021.git \n git push fossil 即可成功 \n \n \n \n 出現 SSL 代表無法進入3443 ，所以改成 3000 但 https 要改成 http ，改完後即可成功推送。 \n 完成後如下圖 : \n \n \xa0 \n', 'tags': '', 'url': 'W15.html'}, {'title': 'using geometry', 'text': 'We saw this simple two-link robot in the previous lecture about forward kinematics. \n 我們在上一堂關於正向運動學的講座中看到了這個簡單的二連桿機構。 \n \xa0 \n The tooltip pose of this robot is described simply by two numbers, the coordinates x and y with respect to the world coordinate frame. \n 該機構的工具提示姿態由兩個數字簡單描述，相對於世界的坐標系的坐標的X和Y。 \n \xa0 \n So, the problem here is that given x and y, we want to determine the joined angles, q1 and q2. \n 所以，這個問題在這裡是給定 x 跟 y ，我們想要求出這個節點的角度 q1 跟 q2 。 \n \xa0 \n The solution that we’re going to follow in this particular section is a geometric one. \n 這節我們將遵循這個特別的幾何方法來解決。 \n \xa0 \n We’re going to start with a simple piece of construction. \n 我們將從一個簡單的結構開始。 \n \xa0 \n We’re going to overlay the red triangle on top of our robot. \n 我們將一個紅色的三角形覆蓋在機構上。 \n \xa0 \n We know that the end point coordinate is x, y, so the vertical height of the triangle is y, the horizontal width is x. \n 我們知道結束的點坐標是x跟y，所以三角形的垂直距離是y，水平距離是x。 \n \xa0 \n And, using Pythagoras theorem, we can write r squared equals x squared plus y squared. \n 然後，利用畢氏定理，我們可以寫出 r 2  = x 2  +y 2 。 \n \xa0 \n So far, so easy. \n 到這裡很容易。 \n \xa0 \n Now, we’re going to look at this triangle highlighted here in red and we want to determine the angle alpha. \n 現在，我們開始看到這個以紅色突出顯示的三角形然後我們想確定α角。 \n \xa0 \n In order to do that, we need to use the cosine rule. \n 為了做到這點，我們需要用到餘弦定理。 \n \xa0 \n And, if you’re a little rusty on the cosine rule, here is a bit of a refresher. \n 如果你對餘弦定理有點生疏，這裡有一點複習。 \n \xa0 \n We have an arbitrary triangle. \n 我們有任意一個三角形。 \n \xa0 \n We don’t have any right angles in it and we’re going to label the length of this edge as A and the angle opposite that edge, we’re going to label as little a. \n 我們沒有任何直角，我們將這條邊的長度標記為 A，而與該邊相對的角度，我們將標記為小 a。 \n \xa0 \n And, we do the same for this edge and this angle, and this edge and this angle. \n 並且，我們對這條邊和這個角，以及這條邊和這個角做同樣的事情。 \n \xa0 \n So, all together, the sides are labelled capitals A, B and C, and the angles are labelled little a, little b, and little c. \n 因此，所有邊都標記為A、B、C，角標記為a、b、c。 \n \xa0 \n So, the cosine rule is simply this relationship here. \n 餘弦定理就是這種關係。 \n \xa0 \n It’s a bit like Pythagoras’ theorem except for this extra term on the end with the cos a in it. \n 它有點像畢達哥拉斯的定理，除了末尾有cos a以外。 \n \xa0 \n Now, let’s apply the cosine rule to the particular triangle we looked at a moment ago. \n 現在，讓我們將餘弦定理用於我們剛才所看到的三角形。 \n \xa0 \n It’s pretty straightforward to write down this particular relationship. \n 寫下這種特殊關係非常簡單。 \n \xa0 \n We can isolate the term cos alpha which gives us the angle alpha that we’re interested in. \n 我們可以分離出cosα，它給出了我們需要的角度α。 \n \xa0 \n And, it’s defined in terms of the constant link lengths, A1 and A2 and the position of the end effector, x and y. \n 而且，他是根據連桿長度A1跟A2以及末端執行器位置x、y來定義的。 \n \xa0 \n We can write this simple relationship between the angles alpha and q2. \n 我們可以寫出簡單的關係在角度α跟q2之間。 \n \xa0 \n And, we know from the shape of the cosine function that cos of q2 must be equal to negative of cos alpha. \n 而且，我們從餘弦函數的形狀知道，cosq2必須等於-cosα。 \n \xa0 \n This time, let’s just write an expression for the cosine of the joined angle q2. \n 這一次，讓我們為節點角q2的餘弦函數寫一個表示式。 \n \xa0 \n Now, we’re going to draw yet another red triangle and we’re going apply some simple trigonometry here. \n 現在，讓我們畫一個另外的三角形然後利用簡單的三角函數。 \n \xa0 \n If we know q2, then we know this length and this length of the red triangle. \n 如果我們知道q2，甚至我們知道這個長度和這個紅色三角形的長度。 \n \xa0 \n We can write this relationship for the sine of the joined angle q2. \n 我們可以寫出節點角q2的正弦關係。 \n \xa0 \n Now, we can consider this bigger triangle whose angle is beta and this side length of this triangle is given here in blue. \n 現在，我們可以知道這個大的三角形，角度是β，然後由藍色表示此三角形的邊。 \n \xa0 \n And, the length of the other side of the triangle is this. \n 且三角形另一邊長度是這個。 \n \xa0 \n So, now we can write an expression for the angle beta in terms of these parameters here \n 所以，現在我們可以根據這些參數寫出角度β的表達式。 \n \xa0 \n Going back to the red triangle that we drew earlier, we can establish a relationship between q1 and the angle beta. \n 回到我們之前畫的紅色三角形，我們可以建立q1和角度β之間的關係。 \n \xa0 \n Introduce yet another angle, this one gamma and we can write a relationship between the angle gamma and the tooltip coordinates x and y. \n 引入另一個角度，γ，我們可以寫出角度γ和工具提示坐標x、y之間的關係。 \n \xa0 \n Now, we can write a simple relationship between the angles that we’ve constructed, gamma and beta and the joined angle we’re interested in which is q \n 現在，可以寫出我們建構的角度γ和β與我們感興趣的節點角q之間的簡單關係。 \n \xa0 \n And, the total relationship looks something like this. \n 而且，整個關係看起來像這樣。 \n \xa0 \n Quite a complex relationship, it gives us the angle of joined one, that’s q1 in terms of the end effector coordinates y and x, and a bunch of constants, a1 and a2, and it’s also a function of the second joint angle, q2. \n 相當複雜的關係，它為我們提供了連接的角度，即末端執行器坐標q1的y和x，以及一系列常數a1和a2，它也是第二個節點角q2的函數。 \n \xa0 \n So, let’s summarize what it is that we have derived here. \n 所以，讓我們總結一下我們在這裡得出的結論。 \n \xa0 \n We have an expression for the cosine of q2 and we have an expression for q1. \n 我們有cosq2以及q1的表達式。 \n \xa0 \n Now, the cosine function is symmetrical about 0. \n 現在，餘弦函數在0對稱。 \n \xa0 \n So, if we know the value of the cosine of q2, then there are two possible solutions a positive angle and a negative angle. \n 所以，如果我們知道cosq2的值可能有兩種解，正角或負角。 \n \xa0 \n We’re going to explicitly choose the positive angle. Which means that I can write this expression here. \n 我們將明確選擇正角。這意味著我可以在這裡寫這個表達式。 \n \xa0 \n And now, we have what we call the inverse kinematic solution for this two-link robot. \n 現在，我們有了這個二連桿機構的逆向運動學解決方法。 \n \xa0 \n We have an expression for the two joined angles, q1 and q2 in terms of the end effector pose x and y, and a bunch of constants. \n 我們有兩個節點角q1和q2的表達式，根據末端執行器姿勢x和y以及一系列常數。 \n \xa0 \n You notice that the two equations are not independent. The equation for q1, in fact, depends on the solution for q2. \n 你注意到這兩個方程式不是獨立的事實上，q1 的方程取決於 q2 的解。 \n \xa0 \n In this case, q2 is negative and we’re going to write the solution for q2 with a negative sign in front of the inverse cosine. \n 在這種情況下，q2是負數，我們將用負號在cos -1 前寫出q2的解。 \n \xa0 \n Now, we need to solve for q1, so we’re going to introduce this particular red triangle, the angle beta that we solved previously, and the angle gamma which is defined in terms of y and x. \n 現在，我們需要求解q1，因此我們將利用這個紅色三角形，我們之前求解的角度β以及根據y、x定義的角度γ。 \n \xa0 \n Now, we write a slightly different relationship between q1, gamma and beta, different to what we had before. There’s a change of sign involved. \n 現在，我們在q1、γ和β之間寫出略有不同的關係，與我們之前的關係不同。 涉及到符號的變化。 \n \xa0 \n Then, we can substitute all that previous equation and come up with this expression for q1. \n 然後，我們可以替換之前的所有等式，並得出q1的這個表達式。 \n \xa0 \n Again, there is a change of sign here. Previously, this was a negative sign. \n 同樣，這裡的符號發生了變化。 以前，這是一個負號。 \n \xa0 \n And, here in summary form is the solution for the inverse kinematics of our two-link robot when it is in this particular configuration, where q2 is negative. \n 並且，這裡是我們的二連桿機構在這種特定配置下的逆向運動學總結形式，其中q2為負。 \n \xa0 \n Let’s compare the two solutions, the case where q2 is positive and the case where q2 is negative. \n 讓我們比較兩個解決方案，q2為正的情況和q2為負的情況。 \n 結論 : 可以利用最終位置的 x、y 來計算機構的轉角 q1、q2 \n q1 =\xa0\xa0 tan -1  (y/x) - tan -1  (a2 sinq2/a1+a2 cosq2) \n q2 =\xa0\xa0 cos -1  (x 2 +y 2 -a1 2 -a2 2 /2a1a2) \n', 'tags': '', 'url': 'using geometry.html'}, {'title': 'using algebra', 'text': "Here we have the same two link robot as we just looked at but this time we're going to solve it using an analytical approach, that is we're going to rely much more on algebra, particular linear algebra rather than geometry. \n 在這裡，我們有與剛才看到的相同的二連桿機構，但這次我們將使用分析方法來解決它，也就是說，我們將更多地依賴代數，特定的線性代數而不是幾何。 \n \xa0 \n We have an expression E, which is the homogeneous transformation which represents the pose of the robots endefector and we looked at this in the last lecture, we can write the endefector pose as a sequence of elementary homogeneous transformations. \n 我們有一個表達式  E ，它是表示機械手臂位置的齊次變換，我們在上一課中看過這個，我們可以將機械手臂位置寫為一系列基本齊次變換。 \n \xa0 \n A rotation by Q1, a translation along the X direction by A1, a rotation by Q2 and then a translation in the X direction by A2. \n Q1 旋轉， A1 沿 x 方向平移， Q2 旋轉，然後 A2 沿 x 方向平移。 \n \xa0 \n If I expand this out, multiply all the transformations together, I get the expression shown here ; a three by three homogeneous transformation matrix representing the pose of the robot's endefector. \n 如果我將其展開，將所有變換相乘，就會得到此處所示的表達式；一個三乘三的齊次變換矩陣，表示機械手臂的最終位置。 \n \xa0 \n Now for this particular two link robot , we are only interested in the position of its endefector , it's X and Y co - ordinate and they are these two elements within the homogeneous transformation matrix , so I'm going to copy those out . \n 現在對於這個特殊的二連桿機構，我們只對它機械手臂的位置感興趣，它是 x 和 y 坐標，它們是齊次變換矩陣中的這兩個元素，所以我將把它們複製出來。 \n \xa0 \n So here again is our expression for X and Y and what we're going to do is a fairly common trick , we're going to square and add these two equations and I get a relationship that looks like this . \n 所以這裡又是我們對 x 和 y 的表達式，我們要做的是一個相當常見的技巧，我們要平方並添加這兩個方程，我得到一個看起來像這樣的關係式。 \n \xa0 \n Now I can solve for the joint angle Q2 in terms of the endefector pose X and Y and the robot's constants A1 and A2. \n 現在我可以根據機械手臂位置 x 和 y 以及機器人的常數 A1 和 A2 來求解節點角度 Q2 。 \n \xa0 \n Now what I'm going to do is apply the sum of angles identity . \n 現在我要做的是應用角度之和的特性。 \n \xa0 \n I'm going to expand these terms, sine of Q1 plus Q2 or cos of Q1 plus Q2 and to make life a little bit easier, I'm going to make some substations, so where ever I had cos Q2, I'm going to write C2 and where ever I had sine Q2, I'm going to write S2. \n 我將展開這些項， Q1 的正弦加 Q2 或 Q1 的 cos 加 Q2 ，為了讓生活更輕鬆一點，我將建立一些部份，所以只要有 cos Q2 ，我就會去取代 C2 並且在我有 sinQ2  的地方，取代為 S2 。 \n \xa0 \n It's a fairly common shorthand when people are looking at robot kinematic equations. And here are the equations after making those substitutions. \n 當人們解決機器人運動學方程時，這是一個相當常見的快速記法。這是進行這些替換後的方程式。 \n \xa0 \n Looking at these two equations, I can see that they fall into a very well known form and for that form there is a very well known solution. \n 看看這兩個方程，我可以看到它們屬於一個眾所周知的形式，對於這種形式，有一個眾所周知的解決方案。 \n \xa0 \n So I'm going to consider just one of the equations, the equation for Y and using our well known identity and it's solution, I can determine the values for the variables little a, little b and little c and once l've determined those, then I can just write down the solution for Q1, which x is the equivalent of theta in this particular case. \n 所以我將只考慮其中一個方程式， Y ，使用我們眾所周知的恆等式和它的解，我可以確定變量 a 、 b 、 c  的值，一旦我確定了這些，然後我可以寫下 Q1 的解決方案，在這種特殊情況下， x 相當於θ。 \n \xa0 \n Here again is our expression for Q1, copied over from the previous slide and we may remember from earlier in our workings that we determined this particular relationship; X squared plus Y squared is equal to this particular complex expression. \n 這裡再次是我們對 Q1 的表達式，從上一張幻燈片複製過來，我們可能還記得在我們工作的早期，我們確定了這種特殊關係； X 2 加 Y 2 等於這個特定的複雜表達式。 \n \xa0 \n So I can substitute that in and do some simplification and I end up with this slightly less complex expression for Q1. \n 因此，我可以將其替換並進行一些簡化，最終得到Q1的這個稍微不那麼複雜的表達式。 \n \xa0 \n And it is the same expression that I got following the geometric approach in the previous section. \n 這與我在上一節中遵循幾何方法得到的表達式相同。 \n", 'tags': '', 'url': 'using algebra.html'}, {'title': 'W16', 'text': '', 'tags': '', 'url': 'W16.html'}, {'title': '1. Onshape 零組件繪製', 'text': 'O nshape 連結 \n STL檔連結 \n 繪製影片 :\xa0 \n \n', 'tags': '', 'url': '1. Onshape 零組件繪製.html'}, {'title': '2.建立 CoppeliaSim 4.1.0 MTB robot 場景', 'text': '檔案連結 :\xa0 W16_exam \n 操作影片 : \n \n', 'tags': '', 'url': '2.建立 CoppeliaSim 4.1.0 MTB robot 場景.html'}, {'title': '3.手臂末端加入吸盤', 'text': '檔案連結 : \n w16_part3 \n 操作影片 : \n \n 主要程式 : \n function sysCall_init() \n    axis1=sim.getObjectHandle(\'MTB_axis1\')\n    axis2=sim.getObjectHandle(\'MTB_axis2\')\n    axis3=sim.getObjectHandle(\'MTB_axis3\')\n    axis4=sim.getObjectHandle(\'MTB_axis4\')\n    mtb3=sim.getObjectHandle(\'MTB_link3\')\n    suctionPad=sim.getObjectHandle(\'suctionPad\')\n    BaseFrame=sim.getObjectHandle("BaseFrame")\n    block =sim.getObjectHandle("block")\n    deg1 = 0\n    deg2 = 0\n    distance3 = 0\n    modelBase=sim.getObjectHandle(sim.handle_self)\n    robotBase=modelBase\n    robotName=\'suctionPad\'\n    deg = math.pi/180\n     \nend\nfunction sysCall_actuation() \n    calibration = 0.0042\n    message, auxiliaryData=sim.getSimulatorMessage()\n        while message ~= -1 do\n            key=auxiliaryData[1]\n            sim.addStatusbarMessage(\'????? key:\'..key)\n            if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==112) then --p activate the suction pad\n                sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),"active",\'true\')\n                end -- if p\n                if (auxiliaryData[1]==113) then --q deactivate the suction pad\n                sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),\'active\',\'false\')\n                end -- if q\n                if (auxiliaryData[1]==108) then --l \n                     deg1 = deg1+0.4*deg\n                     sim.setJointPosition(axis1, deg1)\n                end -- if l\n                if (auxiliaryData[1]==114) then --r \n                     deg1 =deg1-0.4*deg\n                     sim.setJointPosition(axis1, deg1)\n                end -- if r\n                 if (auxiliaryData[1]==103) then --g\n                     deg2 =deg2-0.4*deg\n                     sim.setJointPosition(axis2, deg2)\n                end -- if r\n                 if (auxiliaryData[1]==104) then --h \n                     deg2 =deg2+0.4*deg\n                     sim.setJointPosition(axis2, deg2)\n                end -- if r\n                if (auxiliaryData[1]==100) then --d \n                     distance3 = distance3 + 0.03 + calibration\n                     sim.setJointPosition(axis3, distance3)\n                end -- if d\n                if (auxiliaryData[1]==117) then --u\n                     distance3 = distance3 - 0.03 - calibration\n                     sim.setJointPosition(axis3, distance3)\n                end -- if u\n                if (auxiliaryData[1]==98) then --b\n                     deg1 =0\n                     deg2 =0\n                     sim.setJointPosition(axis1, deg1)\n                     sim.setJointPosition(axis2, deg2)\n                end -- if b\n           end  -- if\n    message, auxiliaryData=sim.getSimulatorMessage()\n        end -- while\nend -- function \n 吸盤程式 :\xa0 \n function sysCall_init() \n    s=sim.getObjectHandle(\'suctionPadSensor\')\n    l=sim.getObjectHandle(\'suctionPadLoopClosureDummy1\')\n    l2=sim.getObjectHandle(\'suctionPadLoopClosureDummy2\')\n    b=sim.getObjectHandle(\'suctionPad\')\n    suctionPadLink=sim.getObjectHandle(\'suctionPadLink\')\n \n    infiniteStrength=sim.getScriptSimulationParameter(sim.handle_self,\'infiniteStrength\')\n    maxPullForce=sim.getScriptSimulationParameter(sim.handle_self,\'maxPullForce\')\n    maxShearForce=sim.getScriptSimulationParameter(sim.handle_self,\'maxShearForce\')\n    maxPeelTorque=sim.getScriptSimulationParameter(sim.handle_self,\'maxPeelTorque\')\n \n    sim.setLinkDummy(l,-1)\n    sim.setObjectParent(l,b,true)\n    m=sim.getObjectMatrix(l2,-1)\n    sim.setObjectMatrix(l,-1,m)\nend\n \nfunction sysCall_cleanup() \n--[[\n    sim.setLinkDummy(l,-1)\n    sim.setObjectParent(l,b,true)\n    m=sim.getObjectMatrix(l2,-1)\n    sim.setObjectMatrix(l,-1,m)\n]]--\nend\n \nfunction sysCall_sensing() \n    parent=sim.getObjectParent(l)\n    if (sim.getScriptSimulationParameter(sim.handle_self,\'active\')==false) then\n        if (parent~=b) then\n            sim.setLinkDummy(l,-1)\n            sim.setObjectParent(l,b,true)\n            m=sim.getObjectMatrix(l2,-1)\n            sim.setObjectMatrix(l,-1,m)\n        end\n    else\n        if (parent==b) then\n            -- Here we want to detect a respondable shape, and then connect to it with a force sensor (via a loop closure dummy dummy link)\n            -- However most respondable shapes are set to "non-detectable", so "sim.readProximitySensor" or similar will not work.\n            -- But "sim.checkProximitySensor" or similar will work (they don\'t check the "detectable" flags), but we have to go through all shape objects!\n            index=0\n            while true do\n                shape=sim.getObjects(index,sim.object_shape_type)\n                if (shape==-1) then\n                    break\n                end\n                if (shape~=b) and (sim.getObjectInt32Parameter(shape,sim.shapeintparam_respondable)~=0) and (sim.checkProximitySensor(s,shape)==1) then\n                    -- Ok, we found a respondable shape that was detected\n                    -- We connect to that shape:\n                    -- Make sure the two dummies are initially coincident:\n                    sim.setObjectParent(l,b,true)\n                    m=sim.getObjectMatrix(l2,-1)\n                    sim.setObjectMatrix(l,-1,m)\n                    -- Do the connection:\n                    sim.setObjectParent(l,shape,true)\n                    sim.setLinkDummy(l,l2)\n                    break\n                end\n                index=index+1\n            end\n        else\n            -- Here we have an object attached\n            if (infiniteStrength==false) then\n                -- We might have to conditionally beak it apart!\n                result,force,torque=sim.readForceSensor(suctionPadLink) -- Here we read the median value out of 5 values (check the force sensor prop. dialog)\n                if (result>0) then\n                    breakIt=false\n                    if (force[3]>maxPullForce) then breakIt=true end\n                    sf=math.sqrt(force[1]*force[1]+force[2]*force[2])\n                    if (sf>maxShearForce) then breakIt=true end\n                    if (torque[1]>maxPeelTorque) then breakIt=true end\n                    if (torque[2]>maxPeelTorque) then breakIt=true end\n                    if (breakIt) then\n                        -- We break the link:\n                        sim.setLinkDummy(l,-1)\n                        sim.setObjectParent(l,b,true)\n                        m=sim.getObjectMatrix(l2,-1)\n                        sim.setObjectMatrix(l,-1,m)\n                    end\n                end\n            end\n        end\n    end\n    if (sim.getSimulationState()==sim.simulation_advancing_lastbeforestop) then\n        sim.setLinkDummy(l,-1)\n        sim.setObjectParent(l,b,true)\n        m=sim.getObjectMatrix(l2,-1)\n        sim.setObjectMatrix(l,-1,m)\n    end\nend\n \n', 'tags': '', 'url': '3.手臂末端加入吸盤.html'}, {'title': '4.逆向運動學函式', 'text': 'W16 part_4 \n 執行影片 : \n \n python\xa0 (x,y) 求法函式 \n # for acos, atan2 and sin\nimport math\nimport sys\n \n# radian to degree\ndeg = 180/math.pi\n# link 1 length\na1 = 0.457\n# link 2 length\na2 = 0.426\n# derivated based up https://www.youtube.com/watch?v=IKOGwoJ2HLk&t=311s\n \ndef ik(x, y):\n    # (x, y)  need to be located inside the circle with radius a1+a2\n    if (x**2 + y**2) <= (a1+ a2)**2:\n        q2 = -math.acos((x**2+y**2-a1**2-a2**2)/(2*a1*a2))\n        q1 = math.atan2(y, x) + math.atan2((a2*math.sin(q2)), (a1+a2*math.cos(q2)))\n        # The decimal point of number is rounded to the 4th place\n        return [round(q1*deg, 4), round(q2*deg, 4)]\n    else:\n        print("Over range!")\n        # end the script execution\n        sys.exit()\n \ntheta = ik(-0.3, -0.55)\n \nprint(theta[0], theta[1]) \n \n', 'tags': '', 'url': '4.逆向運動學函式.html'}, {'title': '5.Python remote API 逆向運動學函式', 'text': '檔案連結 : \n W16 robot_5 \n 操作影片 : \n \n', 'tags': '', 'url': '5.Python remote API 逆向運動學函式.html'}, {'title': 'Questions and answers', 'text': '', 'tags': '', 'url': 'Questions and answers.html'}, {'title': 'ValueError', 'text': '在push完後要進入近端(9443)繼續編輯，發現進不去顯示ValueError，以及網站內容404。 \n \n 這問題是因為 :\xa0 \n 函數接收變量個數少於函數返回值個數導致的，因為返回4個value \n 其實我並不知道怎麼解決，但我的想法是，既然是 push 後才出現的問題，會不會是 push 出了錯誤，因此我在想能不能把剛剛所 push 的 commit 刪除，回到前一個版本。結果如下 : \n 1. 先使用指令: \n git log --oneline \n 確認目前的 commit 版本，找到你想回去的版本。 \n 2. 使用 : \n git reset --hard HEAD~1 \n 回到前一個版本，他會將目前的錯誤版本刪除。 \n 如果想要回到多版之前，後面的數字可以做選擇。 \n 輸入完後要確認版本號是否為你想要的版本。 \n 3. 再來就是 push 上去了，但一般的 push 推不上去，因此要使用 : \n git push --force \n 強制推送，這樣就完成了刪除前一個 commit 。 \n \n 解決後近端也可以順利開啟，網站內容也不再404，可以正常編輯。 \n', 'tags': '', 'url': 'ValueError.html'}, {'title': 'pip無法使用', 'text': '輸入 pip 指令出現錯誤 \n \n 原因 : pip 版本更新過後，無法使用。 \n 解決方法 : \n 輸入\xa0 \n python -m ensurepip \n 變回更新前的版本 \n \n 再次執行 pip ，即可成功執行，但會發現顯示版本過舊的問題。 \n \n 此時使用\xa0 \n python -m pip install --upgrade pip \n 來更新 pip', 'tags': '', 'url': 'pip無法使用.html'}]};